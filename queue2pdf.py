#!/usr/bin/env python3
import json
import os, re, subprocess
import pypandoc
from bs4 import BeautifulSoup
import datetime
from utility_scripts.functions import remove_wiki_elements, get_yaml_data



# * * * * * * * * * * * * * * * * * *
# queue.tmp.json > queue.tmp.html
#

# --- load all contributors
def load_all_contributors(data):
    f = open(data, 'r').read()
    data = json.loads(f)
    all_pages_contributors = []
    for page, _ in data.items():
        page_contributors = data[page]['contributors']
        for contributor in  page_contributors:
            all_pages_contributors.append(contributor)
    all_pages_contributors = sorted(list(set(all_pages_contributors)))
    return all_pages_contributors


# --- load print queue
def load_print_queue(data):
    f = open(data, 'r').read()
    queue = json.loads(f)
    return queue


# --- Pre-process the content html
def text_replacements(html):
    soup = BeautifulSoup(html, "html5lib")
    imgs = soup.find_all("img")
    for img in imgs:
        src = ((img['src'].split('/'))[-1])
        src = re.sub(r'^\d{1,3}px\-', '', src)
        img['src'] = 'images/'+ src 
    html = remove_wiki_elements(soup)
    
    html = re.sub(r'<span class="mw-editsection-bracket">\[</span>.*?edit.*?<span class="mw-editsection-bracket">]', '', html)
    html = re.sub(r'<span class=\"smw-highlighter\" .*?The wikipage input value is empty .*?</div></span>\n', '', html) # to remove the semantic mediawiki error that is displayed as content in some pages, which is caused by empty fields in the article forms.
    html = html.replace('[[File: | ]]', '') # to remove empty image tags
    html = re.sub(r'<table.*?</table>', '', html) # to remove tables from the print queue (unfortunately, \longtables give us the following error: "! Package longtable Error: longtable not in 1-column mode.")
    html = re.sub(r'width=".*?"', '', html) # to force images to template size - this is hacky, should perhaps be done with a html parser!
    html = re.sub(r'height=".*?"', '', html) # to force images to template size - this is hacky, should perhaps be done with a html parser!
    # to remove the TOC that is generated by the wiki
    html = html.replace('<div class="toc" id="toc"><div class="toctitle" id="toctitle"><h2>Contents</h2></div>', '')
    html = html.replace('id="contents"', '')

    html_out = []
    lines = html.split('\n')
    for line in lines:
        if 'toclevel' not in line: # hmm... bit ugly ?
            html_out.append(line)
    html = '\n'.join(html_out)

    return html

def base_header_shift(content):
    content_shifted_headers = pypandoc.convert_text(content, 'html', format='html', extra_args=['--base-header-level=1'])

    return content_shifted_headers

# --- Place content html in template, add information to the article from the all_pages.json
def get_article_template(title, contributors, categories, first_rev, first_rev_user, recent_rev, recent_rev_user, content):
    content = text_replacements(content)
    if len(categories) == 0:
        categories_string = 'Nobody categorized this page yet.'
    else:
        categories_string = ''
        for i, c in enumerate(categories):
            string = '<em>{}</em>'.format(c)
            if i == 0:
                categories_string = categories_string + string
            else:
                categories_string = categories_string + '<br>& ' + string

    template = '''<div class="article_wrapper" text-align="center">
        <h1 class="article_title">{}</h1>
        <div class="article_metadata">CONTRIBUTOR(s)<br> {}</div>
        <hr>
        <div class="article_metadata">CATEGORIZED as<br> {}</div>
        <hr>
        <div class="article_metadata">CREATED at<br> {} <br>by <em>{}</em></div>
        <hr>
        <div class="article_metadata">LAST EDITED at<br> {} <br>by <em>{}</em></div>
        <hr>
        <div class="article_content">{}</div>
    </div>'''.format(title, '<br>& '.join(contributors), categories_string, first_rev, first_rev_user, recent_rev, recent_rev_user, content)
    return template

# --- Write metadata file
def create_metadata_authors_string(authors):
    string = ''
    for author in authors:
        tmp = '- name: {}'.format(author)
        string = string +'\n'+ tmp
    return string

def create_metadata_file(metadata_filename, authors):
    authors_string = create_metadata_authors_string(authors)
    authors = '''
author:
{}
'''.format(authors_string)
    static_metadata = open('metadata.yaml', 'r').read()
    out = open(metadata_filename, 'w+')
    out.write(static_metadata+authors)
    out.close()

# --- write queue to html
def queue2html(queue, html_filename):
    queue_html = ''
    keywords = []
    for page, _ in queue.items():
        if '<table>' not in queue[page]['text']: # the tables make the latex generation break, so unfortunately we filter pages that use a table out...
            # collect content
            title = queue[page]['title']
            contributors = queue[page]['contributors']
            categories = queue[page]['categories']
            first_rev_values = queue[page]['revisions']['first_revision_time']
            first_rev = '{} {} {}, {}:{}h'.format(first_rev_values[2], datetime.date(first_rev_values[0], first_rev_values[1], 1).strftime('%B'), first_rev_values[0], first_rev_values[3], first_rev_values[4])
            first_rev_user = queue[page]['revisions']['first_revision_user']
            first_rev_comment = ''
            # first_rev_comment = queue[page]['revisions']['first_revision_comment']
            recent_rev_values = queue[page]['revisions']['recent_revision_time']
            recent_rev = '{} {} {}, {}:{}h'.format(recent_rev_values[2], datetime.date(recent_rev_values[0], recent_rev_values[1], 1).strftime('%B'), recent_rev_values[0], recent_rev_values[3], recent_rev_values[4])
            recent_rev_user = queue[page]['revisions']['recent_revision_user']
            recent_rev_comment = ''
            # recent_rev_comment = queue[page]['revisions']['recent_revision_comment']
            content = queue[page]['text']
            current_page_html = get_article_template(title, contributors, categories, first_rev, first_rev_user, recent_rev, recent_rev_user, content)
            queue_html += current_page_html

    queue_html = base_header_shift(queue_html)  
    out = open(html_filename, 'w')
    out.write(queue_html)
    out.close()


# * * * * * * * * * * * * * * * * * *
# queue.tmp.html > queue.pdf
#

# --- check pandoc version
def check_pandoc_version():
    request = subprocess.Popen(["pandoc", "--version"], stdout=subprocess.PIPE)
    version_text = request.communicate()[0].decode()
    version_string = version_text.split('\n')[0]
    version_string = version_string.split(' ')[-1]
    version = int(version_string.split('.')[0])
    return version

# --- use pandoc to convert the html file into a pdf with the LaTeX engine
def html2pdf(html_tmp_filename, metadata_filename, pdf_filename):
    
    # pandoc variables
    # (these are notes)
    # 
    # -V or --variable = insert variable
    # -N or --number-sections = Number section headings in LaTeX, ConTeXt, HTML, or EPUB output. By default, sections are not numbered. Sections with class unnumbered will never be numbered, even if --number-sections is specified.
    # --template=template.tex 
    # --number-offset=1 

    # latex variables
    # 
    # lof = list of figures
    # pagestyle=headings
    # logo=/path/to/image
    # fontsize=100 (doesn't work...)
    # documentclass=twocolumn, article, report, book, memoir

    # parse metadata
    # version of pandoc used in pi cannot read yaml
    # so individual metadata key:value are given
     
    # Read tmp metadata.yaml file (metadata.tmp.yaml)
    metadata = get_yaml_data(metadata_filename)

    # Read the list of authors
    # Convert this list into metadata argument for Pandoc
    metadata_authors = ['--metadata=author:"{}"'.format(authorname) for authorname in metadata['authors'] ]
    metadata_authors = (" ").join(metadata_authors)

    # Check which version of Pandoc is running
    pandoc_version_installed = check_pandoc_version()
    if pandoc_version_installed < 2:
        pandoc_pdf_engine_arg = '--latex-engine'
        print('Selected: Pandoc v1 or higher is installed, --latex-engine is used ...')
    else:
        pandoc_pdf_engine_arg = '--pdf-engine'
        print('Selected: Pandoc v2 or higher is installed, --pdf-engine is used ...')

    # If you want to run the pandoc command directly from the terminal:
    # pandoc -f html -t latex --pdf-engine xelatex --template=templates/latex.twocolumns.tex --title "PRINT KIOSK II" --metadata=title:"Elaine" --metadata=abstract:"ABSTRACT PLACEHOLDER" --metadata=author:"AUTHOR PLACEHOLDER" -N -V papersize=a4 -V version=2.0 -V thanks="Thank you!" -V toc-title="Table of Contents" queue.tmp.html --toc -o test.pdf
    
    cmd = '''pandoc \
-f html \
-t latex \
{pdf_engine_arg} xelatex \
--template=templates/latex.twocolumns.tex \
--title="Print Kiosk II" \
--metadata=abstract:"{abstract}" \
--metadata=title:"{title}" \
{authors} \
-N -V papersize=a4 \
-V thanks="Thanks!" \
-V toc-title="Table of Contents" \
--toc \
{inputfile} \
-o {outputfile}'''.format(
            pdf_engine_arg=pandoc_pdf_engine_arg,
            title=metadata['title'],
            abstract=metadata['abstract'],
            authors=metadata_authors,
            inputfile=html_tmp_filename,
            outputfile=pdf_filename)

    print('Running:', cmd)
    os.system(cmd)

# --- main function, generate the pdf
def queue2pdf(data_json_file, queue_json_file, html_tmp_filename, metadata_filename, pdf_filename):

    # --- load contributors metadata + print queue
    print('---')
    all_pages_contributors = load_all_contributors(data_json_file)
    print('Done: list of all wiki contributors is loaded ...')
    queue = load_print_queue(queue_json_file)
    print('Done: print queue JSON file is loaded ...')

    # --- queue2html
    print('---')
    queue2html(queue, html_tmp_filename)
    print('Done: queue.tmp.html is written ...')

    # --- metadata.yaml
    print('---')
    create_metadata_file(metadata_filename, all_pages_contributors)
    print('Done: metadata.tmp.yaml is written ...')
    
    # --- html2pdf
    print('---')
    html2pdf(html_tmp_filename, metadata_filename, pdf_filename)
    print('Done: {} is written.'.format(pdf_filename))
    print('---')

if __name__ == '__main__':
    queue2pdf('all_pages.json', 'queue.tmp.json', 'queue.tmp.html', 'metadata.tmp.yaml', 'test.pdf')

